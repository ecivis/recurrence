/**
* This is an iterator for a recurrence series, which may optionally be bounded
*/
component accessors="true" {

    /** A valid RRULE */
    property name="rrule" type="string";

    /** The start of the recurrence series, defaulting to today */
    property name="start" type="string";

    /** A datetime upper bound */
    property name="until" type="string";

    /** A numeric upper bound */
    property name="count" type="numeric";

    /**
    * This constructor needs to know where the Jars are located
    * @libPath The absolute filesystem path to the Java dependencies
    * @rrule Any valid RRULE, either written by hand or generated by a RecurrenceRule
    * @start A starting datetime like 20180101T000000Z, or 20180101; default is today
    * @until An upper limit for recurrence like 20181231T233000Z or 20181231
    * @count Restrict the iterator to the specified number of recurrences
    */
    public RecurrenceIterator function init(required string libPath, required string rrule, string start, string until, numeric count) {
        variables.libPath = arguments.libPath;
        variables.rrule = arguments.rrule;
        variables.start = arguments.start ?: "";
        variables.until = arguments.until ?: "";
        variables.count = arguments.count ?: 0;
        variables.iterated = 0;

        return this;
    }

    /**
    * The assessment is based on the rule and bounds, if provided
    */
    public boolean function hasNext() {
        if (variables.count > 0 && variables.iterated >= variables.count) {
            // We've already reached the caller's desired cap

            return false;
        }

        var jrrit = getJRecurrenceRuleIterator();
        if (!jrrit.hasNext()) {
            // No point in continuing; there aren't more based on the rule
            return false;
        }

        if (len(variables.until) == 0) {
            // The caller didn't set an upper limit on the date, so, yes
            return true;
        }

        var jdateNext = jrrit.peekDateTime();
        if (!jdateNext.after(createObject("java", "org.dmfs.rfc5545.DateTime", variables.libPath).parse(variables.until))) {
            // The assumption is that if it's not after, it must be equal to or before
            return true;
        }

        return false;
    }

    /**
    * Returns the next datetime in the recurrence series or an exception if one doesn't exist
    */
    public string function next() {
        variables.iterated++;
        return getJRecurrenceRuleIterator().nextDateTime().toString();
    }

    /**
    * Set a new RRULE which will cause the org.dmfs.rfc5545.recur.RecurrenceRule instance to be recreated
    * @rrule Any valid RRULE, either written by hand or generated by a RecurrenceRule
    */
    public void function setRRule(required string rrule) {
        variables.rrule = arguments.rrule;
        resetJRecurrenceRuleIterator();
    }

    /**
    * Set the start datetime and reset the iterator
    * @start A starting datetime like 20180101T000000Z or simply 20180101
    */
    public void function setStart(required string start) {
        variables.start = arguments.start;
        resetJRecurrenceRuleIterator();
    }

    /**
    * Set the until datetime and reset the iterator
    * @until An upper limit for recurrence like 20181231T233000Z
    */
    public void function setUntil(required string until) {
        variables.until = arguments.until;
        resetJRecurrenceRuleIterator();
    }

    /**
    * Set a numeric restriction on the iterator
    * @count New upper limit
    */
    public void function setCount(required numeric count) {
        variables.count = arguments.count;
        resetJRecurrenceRuleIterator();
    }

    /**
    * The org.dmfs.rfc5545.recur.RecurrenceRule instance is created only when needed, and a fresh one is created if any changes are made
    */
    private object function getJRecurrenceRuleIterator() {
        if (structKeyExists(variables, "jRecurrenceRuleIterator")) {
            return variables.jRecurrenceRuleIterator;
        }

        var jrule = createObject("java", "org.dmfs.rfc5545.recur.RecurrenceRule", variables.libPath).init(variables.rrule);
        var jdate = createObject("java", "org.dmfs.rfc5545.DateTime", variables.libPath).parse(len(variables.start) ? variables.start : dateFormat(now(), "yyyymmdd"));
        var jrrit = jrule.iterator(jdate);

        // Reset the internal count of recurrences delivered too
        variables.iterated = 0;

        variables.jRecurrenceRuleIterator = jrrit;
        return jrrit;
    }

    /**
    * After a change, make a new org.dmfs.rfc5545.recur.RecurrenceRule instance
    */
    private void function resetJRecurrenceRuleIterator() {
        if (structKeyExists(variables, "jRecurrenceRuleIterator")) {
            structDelete(variables, "jRecurrenceRuleIterator");
        }
    }

}